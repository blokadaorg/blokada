// Autogenerated from Pigeon (v12.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Generated class from Pigeon that represents data sent in messages.
struct OpsGateway {
  var publicKey: String
  var region: String
  var location: String
  var resourceUsagePercent: Int64
  var ipv4: String
  var ipv6: String
  var port: Int64
  var country: String? = nil

  static func fromList(_ list: [Any?]) -> OpsGateway? {
    let publicKey = list[0] as! String
    let region = list[1] as! String
    let location = list[2] as! String
    let resourceUsagePercent = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let ipv4 = list[4] as! String
    let ipv6 = list[5] as! String
    let port = list[6] is Int64 ? list[6] as! Int64 : Int64(list[6] as! Int32)
    let country: String? = nilOrValue(list[7])

    return OpsGateway(
      publicKey: publicKey,
      region: region,
      location: location,
      resourceUsagePercent: resourceUsagePercent,
      ipv4: ipv4,
      ipv6: ipv6,
      port: port,
      country: country
    )
  }
  func toList() -> [Any?] {
    return [
      publicKey,
      region,
      location,
      resourceUsagePercent,
      ipv4,
      ipv6,
      port,
      country,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct OpsKeypair {
  var publicKey: String
  var privateKey: String

  static func fromList(_ list: [Any?]) -> OpsKeypair? {
    let publicKey = list[0] as! String
    let privateKey = list[1] as! String

    return OpsKeypair(
      publicKey: publicKey,
      privateKey: privateKey
    )
  }
  func toList() -> [Any?] {
    return [
      publicKey,
      privateKey,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct OpsLease {
  var accountId: String
  var publicKey: String
  var gatewayId: String
  var expires: String
  var alias: String? = nil
  var vip4: String
  var vip6: String

  static func fromList(_ list: [Any?]) -> OpsLease? {
    let accountId = list[0] as! String
    let publicKey = list[1] as! String
    let gatewayId = list[2] as! String
    let expires = list[3] as! String
    let alias: String? = nilOrValue(list[4])
    let vip4 = list[5] as! String
    let vip6 = list[6] as! String

    return OpsLease(
      accountId: accountId,
      publicKey: publicKey,
      gatewayId: gatewayId,
      expires: expires,
      alias: alias,
      vip4: vip4,
      vip6: vip6
    )
  }
  func toList() -> [Any?] {
    return [
      accountId,
      publicKey,
      gatewayId,
      expires,
      alias,
      vip4,
      vip6,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct OpsVpnConfig {
  var devicePrivateKey: String
  var deviceTag: String
  var gatewayPublicKey: String
  var gatewayNiceName: String
  var gatewayIpv4: String
  var gatewayIpv6: String
  var gatewayPort: String
  var leaseVip4: String
  var leaseVip6: String

  static func fromList(_ list: [Any?]) -> OpsVpnConfig? {
    let devicePrivateKey = list[0] as! String
    let deviceTag = list[1] as! String
    let gatewayPublicKey = list[2] as! String
    let gatewayNiceName = list[3] as! String
    let gatewayIpv4 = list[4] as! String
    let gatewayIpv6 = list[5] as! String
    let gatewayPort = list[6] as! String
    let leaseVip4 = list[7] as! String
    let leaseVip6 = list[8] as! String

    return OpsVpnConfig(
      devicePrivateKey: devicePrivateKey,
      deviceTag: deviceTag,
      gatewayPublicKey: gatewayPublicKey,
      gatewayNiceName: gatewayNiceName,
      gatewayIpv4: gatewayIpv4,
      gatewayIpv6: gatewayIpv6,
      gatewayPort: gatewayPort,
      leaseVip4: leaseVip4,
      leaseVip6: leaseVip6
    )
  }
  func toList() -> [Any?] {
    return [
      devicePrivateKey,
      deviceTag,
      gatewayPublicKey,
      gatewayNiceName,
      gatewayIpv4,
      gatewayIpv6,
      gatewayPort,
      leaseVip4,
      leaseVip6,
    ]
  }
}

private class PlusOpsCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return OpsGateway.fromList(self.readValue() as! [Any?])
      case 129:
        return OpsKeypair.fromList(self.readValue() as! [Any?])
      case 130:
        return OpsLease.fromList(self.readValue() as! [Any?])
      case 131:
        return OpsLease.fromList(self.readValue() as! [Any?])
      case 132:
        return OpsVpnConfig.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class PlusOpsCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? OpsGateway {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? OpsKeypair {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? OpsLease {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? OpsLease {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? OpsVpnConfig {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PlusOpsCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PlusOpsCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PlusOpsCodecWriter(data: data)
  }
}

class PlusOpsCodec: FlutterStandardMessageCodec {
  static let shared = PlusOpsCodec(readerWriter: PlusOpsCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PlusOps {
  func doGenerateKeypair(completion: @escaping (Result<OpsKeypair, Error>) -> Void)
  func doGatewaysChanged(gateways: [OpsGateway], completion: @escaping (Result<Void, Error>) -> Void)
  func doSelectedGatewayChanged(publicKey: String?, completion: @escaping (Result<Void, Error>) -> Void)
  func doLeasesChanged(leases: [OpsLease], completion: @escaping (Result<Void, Error>) -> Void)
  func doCurrentLeaseChanged(lease: OpsLease?, completion: @escaping (Result<Void, Error>) -> Void)
  func doSetVpnConfig(config: OpsVpnConfig, completion: @escaping (Result<Void, Error>) -> Void)
  func doSetVpnActive(active: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func doPlusEnabledChanged(plusEnabled: Bool, completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PlusOpsSetup {
  /// The codec used by PlusOps.
  static var codec: FlutterStandardMessageCodec { PlusOpsCodec.shared }
  /// Sets up an instance of `PlusOps` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PlusOps?) {
    let doGenerateKeypairChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PlusOps.doGenerateKeypair", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doGenerateKeypairChannel.setMessageHandler { _, reply in
        api.doGenerateKeypair() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doGenerateKeypairChannel.setMessageHandler(nil)
    }
    let doGatewaysChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PlusOps.doGatewaysChanged", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doGatewaysChangedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let gatewaysArg = args[0] as! [OpsGateway]
        api.doGatewaysChanged(gateways: gatewaysArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doGatewaysChangedChannel.setMessageHandler(nil)
    }
    let doSelectedGatewayChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PlusOps.doSelectedGatewayChanged", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doSelectedGatewayChangedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let publicKeyArg: String? = nilOrValue(args[0])
        api.doSelectedGatewayChanged(publicKey: publicKeyArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doSelectedGatewayChangedChannel.setMessageHandler(nil)
    }
    let doLeasesChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PlusOps.doLeasesChanged", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doLeasesChangedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let leasesArg = args[0] as! [OpsLease]
        api.doLeasesChanged(leases: leasesArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doLeasesChangedChannel.setMessageHandler(nil)
    }
    let doCurrentLeaseChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PlusOps.doCurrentLeaseChanged", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doCurrentLeaseChangedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let leaseArg: OpsLease? = nilOrValue(args[0])
        api.doCurrentLeaseChanged(lease: leaseArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doCurrentLeaseChangedChannel.setMessageHandler(nil)
    }
    let doSetVpnConfigChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PlusOps.doSetVpnConfig", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doSetVpnConfigChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configArg = args[0] as! OpsVpnConfig
        api.doSetVpnConfig(config: configArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doSetVpnConfigChannel.setMessageHandler(nil)
    }
    let doSetVpnActiveChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PlusOps.doSetVpnActive", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doSetVpnActiveChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let activeArg = args[0] as! Bool
        api.doSetVpnActive(active: activeArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doSetVpnActiveChannel.setMessageHandler(nil)
    }
    let doPlusEnabledChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PlusOps.doPlusEnabledChanged", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doPlusEnabledChangedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let plusEnabledArg = args[0] as! Bool
        api.doPlusEnabledChanged(plusEnabled: plusEnabledArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doPlusEnabledChangedChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol PlusVpnEventsProtocol {
  func onVpnStatus(status statusArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class PlusVpnEvents: PlusVpnEventsProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  func onVpnStatus(status statusArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PlusVpnEvents.onVpnStatus", binaryMessenger: binaryMessenger)
    channel.sendMessage([statusArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
