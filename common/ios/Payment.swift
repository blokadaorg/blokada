// Autogenerated from Pigeon (v12.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum PaymentStatus: Int {
  case unknown = 0
  case fetching = 1
  case ready = 2
  case purchasing = 3
  case restoring = 4
  case fatal = 5
}

/// Generated class from Pigeon that represents data sent in messages.
struct Product {
  var id: String
  var title: String
  var description: String
  var price: String
  var pricePerMonth: String
  var periodMonths: Int64
  var type: String
  var trial: Int64? = nil
  var owned: Bool

  static func fromList(_ list: [Any?]) -> Product? {
    let id = list[0] as! String
    let title = list[1] as! String
    let description = list[2] as! String
    let price = list[3] as! String
    let pricePerMonth = list[4] as! String
    let periodMonths = list[5] is Int64 ? list[5] as! Int64 : Int64(list[5] as! Int32)
    let type = list[6] as! String
    let trial: Int64? = isNullish(list[7]) ? nil : (list[7] is Int64? ? list[7] as! Int64? : Int64(list[7] as! Int32))
    let owned = list[8] as! Bool

    return Product(
      id: id,
      title: title,
      description: description,
      price: price,
      pricePerMonth: pricePerMonth,
      periodMonths: periodMonths,
      type: type,
      trial: trial,
      owned: owned
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      title,
      description,
      price,
      pricePerMonth,
      periodMonths,
      type,
      trial,
      owned,
    ]
  }
}

private class PaymentOpsCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return Product.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class PaymentOpsCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Product {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PaymentOpsCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PaymentOpsCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PaymentOpsCodecWriter(data: data)
  }
}

class PaymentOpsCodec: FlutterStandardMessageCodec {
  static let shared = PaymentOpsCodec(readerWriter: PaymentOpsCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PaymentOps {
  func doArePaymentsAvailable(completion: @escaping (Result<Bool, Error>) -> Void)
  func doFetchProducts(completion: @escaping (Result<[Product], Error>) -> Void)
  func doPurchaseWithReceipts(productId: String, completion: @escaping (Result<[String], Error>) -> Void)
  func doRestoreWithReceipts(completion: @escaping (Result<[String], Error>) -> Void)
  func doChangeProductWithReceipt(productId: String, completion: @escaping (Result<String, Error>) -> Void)
  func doFinishOngoingTransaction(completion: @escaping (Result<Void, Error>) -> Void)
  func doPaymentStatusChanged(status: PaymentStatus, completion: @escaping (Result<Void, Error>) -> Void)
  func doProductsChanged(products: [Product], completion: @escaping (Result<Void, Error>) -> Void)
  func doAccountTypeChanged(accountType: String, completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PaymentOpsSetup {
  /// The codec used by PaymentOps.
  static var codec: FlutterStandardMessageCodec { PaymentOpsCodec.shared }
  /// Sets up an instance of `PaymentOps` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PaymentOps?) {
    let doArePaymentsAvailableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PaymentOps.doArePaymentsAvailable", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doArePaymentsAvailableChannel.setMessageHandler { _, reply in
        api.doArePaymentsAvailable() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doArePaymentsAvailableChannel.setMessageHandler(nil)
    }
    let doFetchProductsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PaymentOps.doFetchProducts", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doFetchProductsChannel.setMessageHandler { _, reply in
        api.doFetchProducts() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doFetchProductsChannel.setMessageHandler(nil)
    }
    let doPurchaseWithReceiptsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PaymentOps.doPurchaseWithReceipts", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doPurchaseWithReceiptsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let productIdArg = args[0] as! String
        api.doPurchaseWithReceipts(productId: productIdArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doPurchaseWithReceiptsChannel.setMessageHandler(nil)
    }
    let doRestoreWithReceiptsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PaymentOps.doRestoreWithReceipts", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doRestoreWithReceiptsChannel.setMessageHandler { _, reply in
        api.doRestoreWithReceipts() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doRestoreWithReceiptsChannel.setMessageHandler(nil)
    }
    let doChangeProductWithReceiptChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PaymentOps.doChangeProductWithReceipt", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doChangeProductWithReceiptChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let productIdArg = args[0] as! String
        api.doChangeProductWithReceipt(productId: productIdArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doChangeProductWithReceiptChannel.setMessageHandler(nil)
    }
    let doFinishOngoingTransactionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PaymentOps.doFinishOngoingTransaction", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doFinishOngoingTransactionChannel.setMessageHandler { _, reply in
        api.doFinishOngoingTransaction() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doFinishOngoingTransactionChannel.setMessageHandler(nil)
    }
    let doPaymentStatusChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PaymentOps.doPaymentStatusChanged", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doPaymentStatusChangedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let statusArg = PaymentStatus(rawValue: args[0] as! Int)!
        api.doPaymentStatusChanged(status: statusArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doPaymentStatusChangedChannel.setMessageHandler(nil)
    }
    let doProductsChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PaymentOps.doProductsChanged", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doProductsChangedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let productsArg = args[0] as! [Product]
        api.doProductsChanged(products: productsArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doProductsChangedChannel.setMessageHandler(nil)
    }
    let doAccountTypeChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.common.PaymentOps.doAccountTypeChanged", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      doAccountTypeChangedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let accountTypeArg = args[0] as! String
        api.doAccountTypeChanged(accountType: accountTypeArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      doAccountTypeChangedChannel.setMessageHandler(nil)
    }
  }
}
